{"version":3,"sources":["services/api.js","components/App.js","index.js"],"names":["callToApi","fetch","then","response","json","result","body","Word","console","log","App","useState","userLetter","setUserLetter","lastLetter","setLastLetter","word","setWord","useEffect","className","split","map","eachletter","index","findIndex","eachletterUser","filter","letter","includes","htmlFor","autoComplete","maxLength","type","name","id","value","onChange","ev","inputValue","target","regex","RegExp","match","length","ReactDOM","render","document","getElementById"],"mappings":"kMAYeA,G,MAZG,WAEhB,OAAOC,MAAM,+DACVC,MAAK,SAACC,GAAD,OAAcA,EAASC,UAC5BF,MAAK,SAACC,GAEL,IAAME,EAASF,EAASG,KAAKC,KAE7B,OADAC,QAAQC,IAAIJ,GACLA,O,OCgIEK,MApIf,WACE,MAAoCC,mBAAS,IAA7C,mBAAOC,EAAP,KAAmBC,EAAnB,KACA,EAAoCF,mBAAS,IAA7C,mBAAOG,EAAP,KAAmBC,EAAnB,KACA,EAAwBJ,mBAAS,IAAjC,mBAAOK,EAAP,KAAaC,EAAb,KAsEA,OApEAC,qBAAU,WACRlB,IAAYE,MAAK,SAACC,GAChBc,EAAQd,QAET,IAiED,sBAAKgB,UAAU,OAAf,UACE,iCACE,oBAAIA,UAAU,gBAAd,kCAEF,uBAAMA,UAAU,OAAhB,UACE,oCACE,sBAAKA,UAAU,WAAf,UACE,oBAAIA,UAAU,QAAd,0BAEA,oBAAIA,UAAU,UAAd,SAhDWH,EAAKI,MAAM,IAEZC,KAAI,SAACC,EAAYC,GAMjC,OAAqB,IAJDX,EAAWY,WAC7B,SAACC,GAAD,OAAoBH,IAAeG,KAKjC,oBAAIN,UAAU,SAAd,SACGG,GADyBC,GAKvB,oBAAIJ,UAAU,UAAcI,WAoCjC,sBAAKJ,UAAU,WAAf,UACE,oBAAIA,UAAU,QAAd,8BACA,oBAAIA,UAAU,UAAd,SA3BYP,EAAWc,QAC7B,SAACC,GAAD,OAAsC,IAA1BX,EAAKY,SAASD,MAETN,KAAI,SAACC,EAAYC,GAClC,OACE,oBAAIJ,UAAU,SAAd,SACGG,GADyBC,WA+B1B,uBAAMJ,UAAU,OAAhB,UACE,uBAAOA,UAAU,QAAQU,QAAQ,cAAjC,gCAGA,uBACEC,aAAa,MACbX,UAAU,cACVY,UAAU,IACVC,KAAK,OACLC,KAAK,cACLC,GAAG,cACHC,MAAOrB,EACPsB,SAlGU,SAACC,GACrB,IAAMC,EAAaD,EAAGE,OAAOJ,MACzBK,EAAQC,OAAO,cACnBjC,QAAQC,IAAI6B,GAGRA,EAAWI,MAAMF,GACnBzB,EAAcuB,GAEdvB,EAAc,IAMhBF,EAAc,GAAD,mBAAKD,GAAL,CAAiB0B,cAuF1B,0BAASnB,UAAS,sBA1DFP,EAAWc,QAC7B,SAACC,GAAD,OAAsC,IAA1BX,EAAKY,SAASD,MAETgB,QAuDf,UACE,sBAAMxB,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,kBAChB,sBAAMA,UAAU,kBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,iBAChB,sBAAMA,UAAU,2BC9H1ByB,IAASC,OAAO,cAAC,EAAD,IAASC,SAASC,eAAe,W","file":"static/js/main.494a22b2.chunk.js","sourcesContent":["const callToApi = () => {\r\n  // Llamamos al API\r\n  return fetch('https://palabras-aleatorias-public-api.herokuapp.com/random')\r\n    .then((response) => response.json())\r\n    .then((response) => {\r\n      // Cuando responde el API podemos limpiar los datos aquí\r\n      const result = response.body.Word;\r\n      console.log(result);\r\n      return result;\r\n    });\r\n};\r\n\r\nexport default callToApi;\r\n","import '../styles/App.scss';\nimport { useState, useEffect } from 'react';\nimport callToApi from '../services/api';\n\nfunction App() {\n  const [userLetter, setUserLetter] = useState([]); //donde se almacena las letras de la usuaria (solo las que están bien)\n  const [lastLetter, setLastLetter] = useState(''); //string para almacenar al última letra introducida por la jugadora\n  const [word, setWord] = useState(''); //donde) se va a almacenar la palabra a adivinar\n\n  useEffect(() => {\n    callToApi().then((response) => {\n      setWord(response);\n    });\n  }, []);\n\n  const handlerLetter = (ev) => {\n    const inputValue = ev.target.value;\n    let regex = RegExp('^[a-zA-Z]$');\n    console.log(inputValue);\n\n    //console.log(inputValue.match(regex))\n    if (inputValue.match(regex)) {\n      setLastLetter(inputValue); // no está entrando por aquí cuando pones una letra en el input\n    } else {\n      setLastLetter(''); //si es número no pinta nada porque aquí le estamos diciendo que sea string vacío\n    }\n    // const inputValue = ev.target.value;\n    // console.log(inputValue);\n    //setLastLetter(inputValue);\n\n    setUserLetter([...userLetter, inputValue]);\n  };\n\n  // const handleIncreaseErrors = (ev) => {\n  //   ev.preventDefault();\n  //   let counter = numberOfErrors + 1;\n  //   setNumberOfErrors(counter);\n  // };\n  const renderSolutionLetter = () => {\n    const wordLetter = word.split(''); //wordLetter es el array donde se guarda la palabra en letras\n\n    return wordLetter.map((eachletter, index) => {\n      //Buscamos si coincide la letra:\n      const letterFound = userLetter.findIndex(\n        (eachletterUser) => eachletter === eachletterUser\n      );\n      // si coincide (porque la posición es diferente a -1, pintas la letra)\n      if (letterFound !== -1) {\n        return (\n          <li className='letter' key={index}>\n            {eachletter}\n          </li>\n        );\n      } else {\n        return <li className='letter' key={index}></li>;\n      }\n    });\n  };\n  const numberError = () => {\n    const errorLetter = userLetter.filter(\n      (letter) => word.includes(letter) === false\n    );\n    return errorLetter.length; // filtramos para saber cuantos numeros de errores llevamos  y actualizarlo en la seccion del muñequito\n  };\n  const renderErrorLetters = () => {\n    const errorLetter = userLetter.filter(\n      (letter) => word.includes(letter) === false\n    );\n    return errorLetter.map((eachletter, index) => {\n      return (\n        <li className='letter' key={index}>\n          {eachletter}\n        </li>\n      );\n    });\n  };\n\n  return (\n    <div className='page'>\n      <header>\n        <h1 className='header__title'>Juego del ahorcado</h1>\n      </header>\n      <main className='main'>\n        <section>\n          <div className='solution'>\n            <h2 className='title'>Solución:</h2>\n\n            <ul className='letters'>{renderSolutionLetter()}</ul>\n          </div>\n\n          <div className='feedback'>\n            <h2 className='title'>Letras falladas:</h2>\n            <ul className='letters'>\n              {renderErrorLetters()}\n              {/* <li className='letter'>f</li>\n              <li className='letter'>q</li>\n              <li className='letter'>h</li>\n              <li className='letter'>p</li>\n              <li className='letter'>x</li> */}\n            </ul>\n          </div>\n          <form className='form'>\n            <label className='title' htmlFor='last-letter'>\n              Escribe una letra:\n            </label>\n            <input\n              autoComplete='off'\n              className='form__input'\n              maxLength='1'\n              type='text'\n              name='last-letter'\n              id='last-letter'\n              value={lastLetter}\n              onChange={handlerLetter}\n            />\n          </form>\n        </section>\n        <section className={`dummy error-${numberError()}`}>\n          <span className='error-13 eye'></span>\n          <span className='error-12 eye'></span>\n          <span className='error-11 line'></span>\n          <span className='error-10 line'></span>\n          <span className='error-9 line'></span>\n          <span className='error-8 line'></span>\n          <span className='error-7 line'></span>\n          <span className='error-6 head'></span>\n          <span className='error-5 line'></span>\n          <span className='error-4 line'></span>\n          <span className='error-3 line'></span>\n          <span className='error-2 line'></span>\n          <span className='error-1 line'></span>\n        </section>\n      </main>\n    </div>\n  );\n}\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}