{"version":3,"sources":["services/api.js","components/Header.js","components/Footer.js","components/Dummy.js","components/SoluctionLetters.js","components/ErrorLetters.js","components/Form.js","components/Main.js","components/App.js","routes/Instructions.js","index.js"],"names":["callToApi","fetch","then","response","json","body","Word","Header","className","Footer","to","Dummy","props","numberError","SolutionLetters","word","split","map","eachletter","index","userLetter","findIndex","eachletterUser","ErrorLetters","filter","letter","includes","Form","htmlFor","autoComplete","maxLength","type","name","id","value","lastLetter","onChange","ev","handlerLetter","target","Main","App","useState","setUserLetter","setLastLetter","setWord","useEffect","regex","RegExp","match","length","Instructions","ReactDOM","render","path","element","document","getElementById"],"mappings":"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","file":"static/js/main.983541d8.chunk.js","sourcesContent":["const callToApi = () => {\r\n  // Llamamos al API\r\n  return fetch('https://palabras-aleatorias-public-api.herokuapp.com/random')\r\n    .then((response) => response.json())\r\n    .then((response) => {\r\n      // Cuando responde el API podemos limpiar los datos aquí\r\n      const result = response.body.Word;\r\n      return result;\r\n    });\r\n};\r\n\r\nexport default callToApi;\r\n","import '../styles/Header.scss';\r\nconst Header = () => {\r\n  return (\r\n    <header>\r\n      <h1 className='header__title'>Juego del ahorcado</h1>\r\n    </header>\r\n  );\r\n};\r\nexport default Header;\r\n","import '../styles/Footer.scss';\r\nimport { Link } from 'react-router-dom';\r\nconst Footer = () => {\r\n  return (\r\n    <footer className='footer'>\r\n      <nav>\r\n        <ul className='footer__menu'>\r\n          <li className='footer__menu-item'>\r\n            <Link className='footer__menu-link active' to='/'>\r\n              A jugar\r\n            </Link>\r\n          </li>\r\n\r\n          <li className='footer__menu-item'>\r\n            <Link className='footer__menu-link active' to='/instructions'>\r\n              ¿Cómo se juega?\r\n            </Link>\r\n          </li>\r\n          <li className='footer__menu-item'>\r\n            <Link className='footer__menu-link active' to='/options'>\r\n              Más opciones\r\n            </Link>\r\n          </li>\r\n        </ul>\r\n      </nav>\r\n\r\n      <small className='footer__copy'>© Adalab</small>\r\n    </footer>\r\n  );\r\n};\r\nexport default Footer;\r\n","import '../styles/Dummy.scss';\r\n\r\nconst Dummy = (props) => {\r\n  return (\r\n    <section className={`dummy error-${props.numberError}`}>\r\n      <span className='error-13 eye'></span>\r\n      <span className='error-12 eye'></span>\r\n      <span className='error-11 line'></span>\r\n      <span className='error-10 line'></span>\r\n      <span className='error-9 line'></span>\r\n      <span className='error-8 line'></span>\r\n      <span className='error-7 line'></span>\r\n      <span className='error-6 head'></span>\r\n      <span className='error-5 line'></span>\r\n      <span className='error-4 line'></span>\r\n      <span className='error-3 line'></span>\r\n      <span className='error-2 line'></span>\r\n      <span className='error-1 line'></span>\r\n    </section>\r\n  );\r\n};\r\nexport default Dummy;\r\n","import '../styles/Letters.scss';\r\nconst SolutionLetters = (props) => {\r\n  const renderSolutionLetter = () => {\r\n    const wordLetter = props.word.split(''); //wordLetter es el array donde se guarda la palabra en letras (convertimos la palabra en letras con el metodo split)\r\n    // cogemos el array de la palabra random y la mapeamos. cada una de la sletras la comparamos con las letras del usuario y buscamos la posición\r\n    return wordLetter.map((eachletter, index) => {\r\n      //Buscamos si coincide la letra:\r\n      const letterFound = props.userLetter.findIndex(\r\n        (eachletterUser) => eachletter === eachletterUser\r\n      );\r\n      // si coincide (porque la posición es diferente a -1, pintas la letra)\r\n      if (letterFound !== -1) {\r\n        return (\r\n          <li className='letter' key={index}>\r\n            {eachletter}\r\n          </li>\r\n        );\r\n      } else {\r\n        return <li className='letter' key={index}></li>;\r\n      }\r\n    });\r\n  };\r\n  return (\r\n    <div className='solution'>\r\n      <h2 className='title'>Solución:</h2>\r\n\r\n      <ul className='letters'>{renderSolutionLetter()}</ul>\r\n    </div>\r\n  );\r\n};\r\nexport default SolutionLetters;\r\n","import '../styles/Letters.scss';\r\nconst ErrorLetters = (props) => {\r\n  const renderErrorLetters = () => {\r\n    const errorLetter = props.userLetter.filter(\r\n      (letter) => props.word.includes(letter) === false\r\n    );\r\n    return errorLetter.map((eachletter, index) => {\r\n      return (\r\n        <li className='letter' key={index}>\r\n          {eachletter}\r\n        </li>\r\n      );\r\n    });\r\n  };\r\n  return (\r\n    <div className='feedback'>\r\n      <h2 className='title'>Letras falladas:</h2>\r\n      <ul className='letters'>{renderErrorLetters()}</ul>\r\n    </div>\r\n  );\r\n};\r\nexport default ErrorLetters;\r\n","const Form = (props) => {\r\n  const hadleChange = (ev) => {\r\n    props.handlerLetter(ev.target.value);\r\n  };\r\n\r\n  return (\r\n    <form className='form'>\r\n      <label className='title' htmlFor='last-letter'>\r\n        Escribe una letra:\r\n      </label>\r\n      <input\r\n        autoComplete='off'\r\n        className='form__input'\r\n        maxLength='1'\r\n        type='text'\r\n        name='last-letter'\r\n        id='last-letter'\r\n        value={props.lastLetter}\r\n        onChange={hadleChange}\r\n      />\r\n    </form>\r\n  );\r\n};\r\nexport default Form;\r\n","import Dummy from './Dummy';\r\nimport SolutionLetters from './SoluctionLetters';\r\nimport ErrorLetters from './ErrorLetters';\r\nimport Form from './Form';\r\n\r\nconst Main = (props) => {\r\n  return (\r\n    <main className='main'>\r\n      <section>\r\n        <SolutionLetters word={props.word} userLetter={props.userLetter} />\r\n        <ErrorLetters word={props.word} userLetter={props.userLetter} />\r\n        <Form\r\n          handlerLetter={props.handlerLetter}\r\n          lastLetter={props.lastLetter}\r\n        />\r\n      </section>\r\n      <Dummy numberError={props.numberError()} />\r\n    </main>\r\n  );\r\n};\r\nexport default Main;\r\n","import '../styles/App.scss';\nimport '../styles/Form.scss';\nimport { useState, useEffect } from 'react';\n\nimport callToApi from '../services/api';\nimport Header from './Header';\n\nimport Footer from './Footer';\n\nimport Main from './Main';\nimport { Outlet } from 'react-router';\n\nfunction App() {\n  const [userLetter, setUserLetter] = useState([]); //donde se almacena las letras de la jugadora (todas)\n  const [lastLetter, setLastLetter] = useState(''); //string para almacenar al última letra introducida por la jugadora (si no es permitida no se incluye, por eso no lo pinta aunque marques tecla)\n  const [word, setWord] = useState(''); //donde) se va a almacenar la palabra a adivinar\n\n  //petición random word:\n  useEffect(() => {\n    callToApi().then((response) => {\n      setWord(response);\n    });\n  }, []);\n\n  const handlerLetter = (ev) => {\n    let regex = new RegExp('^[a-zA-Z]$'); // letras permitidas, el resto no lo están\n    // si la letra esta permitida:\n    if (ev.match(regex)) {\n      setUserLetter([...userLetter, ev]);\n    } else {\n      setLastLetter(''); //si es número no pinta nada porque aquí le estamos diciendo que sea string vacío y tampoco se guarda en el estado\n    }\n  };\n\n  const numberError = () => {\n    const errorLetter = userLetter.filter(\n      (letter) => word.includes(letter) === false\n    );\n    return errorLetter.length;\n  };\n\n  return (\n    <div className='page'>\n      <Header />\n      <Main\n        word={word}\n        userLetter={userLetter}\n        handlerLetter={handlerLetter}\n        lastLetter={lastLetter}\n        numberError={numberError}\n      />{' '}\n      {/* Con Outlet añadimos las rutas que están en index.js */}\n      <Outlet />\n      <Footer />\n    </div>\n  );\n}\nexport default App;\n","import '../styles/Instructions.scss';\r\nconst Instructions = () => {\r\n  return (\r\n    <section className='instructions'>\r\n      <p>\r\n        Haz click donde indica \"Escribe una letra\" y escribe tu letra para\r\n        adivinar la palabra secreta. Si fallas la letra te indicará si has\r\n        acertado, ya que se escribirá en su posición correspondiente de la\r\n        solución y si no, se añadirá a las letras falladas.\r\n      </p>\r\n      <p>¡A jugar!</p>\r\n    </section>\r\n  );\r\n};\r\nexport default Instructions;\r\n","// Fichero src/index.js (código nuevo)\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport App from './components/App';\nimport Instructions from './routes/Instructions';\n\nReactDOM.render(\n  <BrowserRouter>\n    <Routes>\n      <Route path='/' element={<App />}>\n        <Route path='/instructions' element={<Instructions />} />\n        <Route path='/options' />\n      </Route>\n    </Routes>\n  </BrowserRouter>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}